## ğŸ§  Insiders' Viewpoints: JavaScript Best Practices

Insiders' Viewpoints: JavaScript Best Practices bÃ¶lÃ¼mÃ¼ne hoÅŸ geldiniz. Bu videoda, birkaÃ§ bulut uygulamasÄ± profesyonelinin JavaScript ile ilgili deneyimlerinden Ã§Ä±kan en iyi uygulamalarÄ± ( *best practices* ) tartÄ±ÅŸmalarÄ±nÄ± dinleyeceÄŸiz. JavaScript ile Ã§alÄ±ÅŸma deneyimlerinizden bazÄ± en iyi uygulamalarÄ± paylaÅŸabilir misiniz? JavaScript ile Ã¶zellikle bu alanda yÄ±llar iÃ§inde Ã§alÄ±ÅŸarak Ã¶ÄŸrendiÄŸim Ã¼Ã§ en iyi uygulamayÄ± paylaÅŸmak istiyorum. Ä°lki IDE kullanÄ±mÄ±dÄ±r. Kod yazmak iÃ§in VS Code veya WebStorm gibi bir ÅŸey kullanmayÄ± seviyorum. *Content assist* ile fonksiyonlara, dokÃ¼mantasyona ve sÄ±nÄ±flara aynÄ± editÃ¶r iÃ§inde bakabiliyorum.

Bu benim iÃ§in Ã§ok gÃ¼Ã§lÃ¼ ve Ã§ok etkili; beni daha Ã¼retken bir geliÅŸtirici yapÄ±yor. Ä°kinci tavsiyem *linter* kullanmak olur. EÄŸer JavaScriptâ€™te yeniseniz ve  *linter* â€™larÄ±n ne olduÄŸunu bilmiyorsanÄ±z, bunlar *Standard Code* yazmanÄ±za yardÄ±mcÄ± olur. Burada ES6 standardÄ± anlamÄ±nda â€œstandardâ€ demiyorum. Bu, ekibinizin fonksiyonlarÄ± ve dokÃ¼mantasyonu nasÄ±l yazacaÄŸÄ±na karar vermesi anlamÄ±nda bir standart olabilir. Ve bu, *version control* ve Ã§akÄ±ÅŸmalarÄ± ( *conflicts* ) Ã§Ã¶zme konusunda Ã§ok Ã¶nemlidir. HayatÄ±nÄ±zÄ± Ã§ok daha kolay hale getirir.

Son olarak Ã¼Ã§Ã¼ncÃ¼ ipucum, JavaScriptâ€™teki farklÄ± paradigmalarÄ± ve desenleri ( *paradigms and patterns* ) Ã¶ÄŸrenmektir. JavaScriptâ€™i *front end* veya *back end* iÃ§in kullandÄ±ÄŸÄ±nÄ±zÄ± varsayarsak, JavaScriptâ€™te kodu nasÄ±l modÃ¼lerleÅŸtireceÄŸinizi Ã¶ÄŸrenin, kodunuzu *unit test* yazmayÄ± kolaylaÅŸtÄ±racak ÅŸekilde nasÄ±l yapÄ±landÄ±racaÄŸÄ±nÄ±zÄ± Ã¶ÄŸrenin, kodu uygulamanÄ±za baÅŸka paketleri iÃ§e aktarmayÄ± ( *import* ) kolaylaÅŸtÄ±racak ÅŸekilde yapÄ±landÄ±rÄ±n. JavaScript ile Ã§alÄ±ÅŸmak yÄ±llar iÃ§inde Ã§ok deÄŸiÅŸti. GÃ¼nÃ¼mÃ¼zde aslÄ±nda oldukÃ§a saÄŸlam ( *robust* ) ve bunun iÃ§in kullanabileceÄŸiniz birÃ§ok araÃ§ var. JavaScriptâ€™inizi *linting* yapmanÄ±zÄ± kesinlikle tavsiye ederim. Benim kiÅŸisel olarak kullandÄ±ÄŸÄ±m gerÃ§ekten iyi bir araÃ§ **XO** adlÄ± bir ÅŸeydir. Harika varsayÄ±lan ayarlara sahip Ã§ok iyi bir  *linter* â€™dÄ±r.

Bunu kodunuz Ã¼zerinde Ã§alÄ±ÅŸtÄ±rÄ±rsÄ±nÄ±z. Bu da belirli standart stilleri takip etmenizi saÄŸlar; bÃ¶ylece siz ve ekibinizdeki herkes kodunuzun iyi gÃ¶rÃ¼ndÃ¼ÄŸÃ¼nden emin olur, ama aynÄ± zamanda umarÄ±m kodunuzdaki hata ve karmaÅŸa miktarÄ±nÄ± da azaltÄ±r. AyrÄ±ca **TypeScript** kullanmanÄ±zÄ± tavsiye ederim. JavaScriptâ€™e harika bir eklentidir ve Ã§oÄŸu zaman mevcut JavaScript projesinin Ã¼zerine, neredeyse hiÃ§ kod deÄŸiÅŸtirmeye gerek kalmadan doÄŸrudan eklenebilir. SonrasÄ±nda kodunuza Ã§ok daha Ã¶nemli bir Ã¶zellik seti ekleyerek onu Ã§ok daha iyi hale getirebilirsiniz. JavaScript ile Ã§alÄ±ÅŸÄ±rken, global deÄŸiÅŸkenler ve fonksiyonlar bildirmekten kaÃ§Ä±nÄ±n. Global deÄŸiÅŸkenler, pencere kapanana kadar silinmedikleri iÃ§in programÄ±nÄ±zÄ± yavaÅŸlatabilir.

AynÄ± deÄŸiÅŸkeni iÃ§eren ve sizin kodunuzdan sonra Ã§alÄ±ÅŸan scriptâ€™ler, deÄŸiÅŸkenlerinizin Ã¼zerine yazacaktÄ±r ( *override* ). Sayfa yÃ¼klenme sÃ¼relerini azaltmak iÃ§in, Ã¶zellikle JSâ€™in amacÄ± bir olaydan ( *event* ) sonra iÅŸlevsellik eklemekse, JSâ€™inizi sayfanÄ±n altÄ±na yerleÅŸtirin. Uzun *for* ifadeleri bildirirken, deÄŸiÅŸkenleri *for* ifadesinin dÄ±ÅŸÄ±nda bildirin. DÃ¶ngÃ¼leri de optimize etmelisiniz. Ã–rneÄŸin, bir dizinin **length** Ã¶zelliÄŸini her iterasyonda okumak yerine, **length** deÄŸerini farklÄ± bir deÄŸiÅŸkende saklayÄ±n. Kodunuzun Ã¶nemli bÃ¶lÃ¼mlerini her zaman yorumlayÄ±n ( *comment* ); bÃ¶ylece siz veya iÅŸ arkadaÅŸlarÄ±nÄ±z, kodu revize etmeniz gerektiÄŸinde kodun amacÄ±nÄ± anlayabilir. JavaScript yazarken, ES6â€™nÄ±n Ã¶zelliklerinden yararlanmayÄ± gerÃ§ekten seviyorum; Ã§Ã¼nkÃ¼ kodumun daha temiz, daha okunabilir ve daha â€œgÃ¼zelâ€ gÃ¶rÃ¼nmesini saÄŸlayabilir; Ã¶rneÄŸin *arrow functions* veya *dot dot dot operator* gibi.

Bu yÃ¼zden JavaScriptâ€™i Ã¶ÄŸrendikten sonra ES6â€™ya biraz dalmanÄ±zÄ± ve onunla eÄŸlenmenizi teÅŸvik ediyorum. JavaScript geliÅŸtiricilerinin aklÄ±nda tutmasÄ± gereken bir en iyi uygulama, global deÄŸiÅŸken kullanÄ±mÄ±ndan kaÃ§Ä±nmaktÄ±r. Bu tavsiyeyi baÅŸka programlama dilleri iÃ§in de duymuÅŸ olabilirsiniz ve oradaki gerekÃ§eler burada da geÃ§erlidir. Ancak Ã¶zellikle JavaScriptâ€™te isim Ã§akÄ±ÅŸmasÄ± ( *name collision* ) riski oldukÃ§a yÃ¼ksektir. GeliÅŸtiricilerin kendi kodlarÄ±nÄ±n yanÄ± sÄ±ra Ã¼Ã§Ã¼ncÃ¼ taraf kÃ¼tÃ¼phaneleri ( *third party libraries* ) de aynÄ± sayfaya dahil etmeleri Ã§ok yaygÄ±ndÄ±r. Ve bu scriptâ€™lerin hepsi aynÄ± global baÄŸlamÄ± ( *global context* ) paylaÅŸÄ±r; bu da, eÄŸer global bir deÄŸiÅŸken iÃ§in Ã¼Ã§Ã¼ncÃ¼ taraf kÃ¼tÃ¼phanelerden biriyle aynÄ± ismi seÃ§erseniz, temelde programlarÄ±nÄ±zdan biri veya her ikisi de Ã§alÄ±ÅŸmayacaÄŸÄ± anlamÄ±na gelir. JavaScript Ã§ok gÃ¼Ã§lÃ¼ bir dildir.

Dikkatli olmazsanÄ±z, hayal edebileceÄŸiniz hemen her ÅŸeyi yapmanÄ±za izin verir; buna kendi ayaÄŸÄ±nÄ±za sÄ±kmak da dahildir. JavaScript ile genellikle takip ettiÄŸim uygulamalar, deÄŸiÅŸkenlerin ve fonksiyonlarÄ±n doÄŸru kapsamlandÄ±rÄ±lmasÄ± ( *proper scoping* ) ve Ã¶zelliklerim iÃ§in *unit* ve *integration tests* yazmaktÄ±r.
